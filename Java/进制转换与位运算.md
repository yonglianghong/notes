1. 十进制转二进制
   - 原理：给定的数循环除以2，直到商为0为止。将每一步除的结果的余数记录下来，然后反过来就得到相应的二进制了。
   - 举例：比如8转二进制，第一次除以2等于4（余数0），第二次除以2等于2（余数0），第三次除以2等于1（余数0），最后一次除以2余数为1，得到的余数依次是0 0 0 1 ，反过来就是1000，计算机内部表示数的字节长度是固定的，比如8位，16位，32位。所以在高位补齐，java中字节码是8位的，所以高位补齐就是00001000。

2. 二进制转十进制
   - 比如8的二进制表示位00001000，去掉补齐的高位就是1000.此时从个位开始计算2的幂（个位是0，依次往后推）乘以对应位数上的数，然后得到的值相加。
   - 即：`（2的0次幂）*0+（2的1次幂）*0+（2的2次幂）*0+（2的3次幂）*1 = 8`

------

3. 异或运算（^）
   - 相同为0，不同为1（只有1个1为1，否则为0）
   - 8^11，即(1000)^(1011)，得到0011，转换10进制就是3

4. 与运算（&）
   - 都为1则1，否则为0
   - 128&129，即(10000000)&(10000001)=10000000，就是128

5. 或运算（|）
   - 只要有一个为1则为1，否则为0
   - 128|129，即(10000000)&(10000001)=10000001，就是129

6. 非运算（~）
   - 1为0，0为1
   - java中所有的数据表示都是用补码的形式来表示

7. 按位左移（<<）
   - m << n，m和n均为整型，且n值必须为正整数，**将m的二进制位全部左移n位**，右边空出的位补零。

8. 按位右移（>>）
   - m >> n，m和n均为整型，且n值必须为正整数，**将m的二进制位全部右移n位**，对左边空出的位，*分两种情况处理*：
     - m为正数，则m右移n位后，左边补n个零；
     - m为负数，则m右移n位后，左边补n个符号位。

9. 无符号右移（>>>）
   - 无符号右移，忽略符号位，空位都以0补齐

------

10. 原码、反码、补码
    - 计算机中所有的数都是用位序列表示的，最高位是符号位，1表示负数，0表示正数
    - 原码：实际的值再加上第一位符号位，比如+1=0000 0001，-1=1000 0001，第一位是符号位，所以8位二进制数取值范围为[1111 1111,  0111 1111]，即[-127, 127]
    - 反码：正数的反码是本身，负数的反码是在其原码的基础上，符号位不变，其余位取反，比如[-1] = [10000001]原 = [11111110]反
    - 补码：正数的补码是自身，负数的补码是在反码的基础上+1，比如[-1] = [10000001]原 = [11111110]反 = [11111111]补
    - 计算器中只设计加法器，为了让符号位参与运算，所以的数字都是补码的形式表示的
    - http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html

------

11. 异或运算特点
    - 0^0=0, 0^1=1 0异或任何数=任何数
    - 1^0=1, 1^1=0 1异或任何数=任何数取反
    - 任何数异或自己=把自己置0

------

12. 移位符与等号组合（<<=或>>=或>>>=）使用
    - 移位符左边的值会移动由右边的的值指定位数，再将得到的结果赋给左边的变量
    - 对byte或short进行无符号右移时，得到的可能不是正确结果，会先被转换成int类型，再进行右移，然后被截断，赋值给原来的类型（这种情况，可直接使用>>>，避免>>>=）

------

13. 位移运算总结
    - 整体分两种，左移和右移，左移直接移
    - 右移考虑有符号和无符号，有符号（符号是什么高位就补什么，负补1，正补0），无符号一律补0

------

14. java打印二进制字符

    - Integer.toBinaryString()，传入较小的类型会自动转换为int
    - Long.toBinaryString()

    