##### 1. RTTI

RTTI（Run-Time Type Identification）是指在运行时识别一个对象的具体的类型。

主要有三种方式：

1. 转型

   Java中，允许自由地upcast，但是downcast必须显式指明。编译器会检查是否合理，检查就会去获取对象具体的类型。

   ```java
   Shape myShape = new Circle( ); // 编译之后，Java就知道myShape所指向对象的实际类型是Circle，而外观类型是Shape
   Circle myCircle = (Circle)myShape;　// 需显示声明downcast　
   ```

2. Class对象

   类加载器将`.class`文件加载进方法区，然后在堆里面生成一个`java.lang.Class`对象，这个Class对象代表着类相关的信息。对于某个对象，可以通过`xx.getClass()`方法返回Class对象，从而知道对象具体的类型信息。

   ```java
   List<Object> myList = new ArrayList<Object>();
   Integer i = new Integer(5);
   myList.add(i);
    
   Class myClass = myList.get(0).getClass();
   System.out.println(myClass.getName()); // java.lang.Integer
   ```

3. 利用操作符`instanceof`或方法Class.isInstance()来在运行时判断某个对象的类型信息。

参考：

https://www.cnblogs.com/dosmile/p/6444429.html

https://www.zhihu.com/question/21080782

《Think in Java》=>《C programmer attempting to think in Java》



##### 2. 反射

>如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，并利用这些信息做一些有用的事。换句话说，在编译时，编译器必须知道所有要通过RTTI来处理的类。
>
>初看起来这似乎不是个限制，但是假设你获取了一个指向某个并不在你的程序空间中的对象的引用；事实上，在编译时你的程序根本没法获知这个对象所属的类。例如，假设你从硬盘文件，获知网络连接中获取了一串字节，并且你被告知这些字节代表一个类。既然这个类在编译器为你的程序生成代码之后很久才会出现，那么怎样才能使用这样的类呢？

Java的反射是指程序在运行期可以拿到一个对象的所有信息。

反射的作用：

- 运行时动态加载类，创建实例（类名可以在程序运行时动态指定或者从配置文件读取，不用new（可以理解为正射），达到解耦）
  - 比如，加载驱动类：`Class.forName("com.mysql.jdbc.Driver")`，可根据实际情况加载mysql或oracle
  - Spring根据配置文件加载bean
- 用`Method.invoke`执行方法（动态代理）

`java.lang.Class`和`java.lang.reflect`类库一起构成了对反射概念的支持，主要包括Field、Method、Constructor和Proxy类。

1. Class

   Class类如下：

   ```java
   public final class Class {
     	/* Constructor. Only the Java Virtual Machine creates Class
        * objects.
        */
       private Class() {}
   }
   ```

   由此可见，只有JVM才能创建Class实例，包含`class`的如下信息：

   - 权限修饰符
   - 类名
   - 参数化类型（泛型）
   - 接口
   - 注解
   - 字段（重点）
   - 方法（重点）
   - 构造器（重点）

   有三种方法可以获得Class实例：

   1. 直接通过一个`class`的静态变量`class`获取：

      ```java
      Class cls = String.class;
      ```

   2. 通过对象的`getClass()`方法获取

      ```java
      String s = "Hello";
      Class cls = s.getClass();
      ```

   3. 如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：

      ```java
      Class cls = Class.forName("java.lang.String");
      ```

   `Class`实例在JVM中是唯一的，所以，上述方法获取的`Class`实例是同一个实例。

   `Class`实例在比较时`==`和`instanceof`的差别：

   ```java
   Integer n = new Integer(123);
   
   boolean b1 = n instanceof Integer; // true，因为n是Integer类型
   boolean b2 = n instanceof Number; // true，因为n是Number类型的子类
   
   boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class
   boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class
   ```

   `instanceof`不但匹配指定类型，还匹配指定类型的子类。而用`==`判断`class`实例可以精确地判断数据类型，但不能作子类型比较。

2. 字段、方法、构造方法和继承

   Class类方法：

   ```java
   // 字段
   Field getField(name)：获取指定名称的public的field（包括父类）
   Field getDeclaredField(name)：获取指定名称的public、protected、default、private的field（不包括父类）
   Filed[] getFields()：获取所有的public的filed（包括父类）
   Field[] getDeclaredFields()：获取所有的public、protected、default、private的filed（不包括父类） 
   
   // 方法
   Method getMethod(name, Class...)：获取某个public的Method（包括父类）
   Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）
   Method[] getMethods()：获取所有public的Method（包括父类）
   Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）
   
   // 构造方法
   getConstructor(Class...)：获取某个public的Constructor
   getDeclaredConstructor(Class...)：获取某个Constructor
   getConstructors()：获取所有public的Constructor
   getDeclaredConstructors()：获取所有Constructor
   
   // 继承
   Class getSuperclass()：获取父类类型
   Class[] getInterfaces()：获取当前类实现的所有接口
   ```

   使用示例：

   ```java
   public class Test {
   
       public static void main(String[] args) throws Exception {
   
           Person person = new Person("Xiao Ming");
           System.out.println(person.getName()); // Xiao Ming
           Class c = person.getClass();
           for(Field f : c.getDeclaredFields()){
               System.out.println(f.getName()); // name
               System.out.println(f.getType()); // class java.lang.String
               System.out.println(f.getModifiers()); // 2
           }
   
           Field field = c.getDeclaredField("name");
           field.setAccessible(true); // private变量
           field.set(person, "Xiao Huang");
           System.out.println(person.getName()); // Xiao Huang
   
           Class std = Student.class;
           Student student = new Student("Zhang San");
           System.out.println(std.getMethod("getScore")); // public int Student.getScore()
           System.out.println(std.getDeclaredMethod("getGrade")); // private int com.ylh.test.Student.getGrade()
           Method m1 = std.getMethod("setScore", int.class);
           m1.invoke(student, 99);
           System.out.println(student.getScore()); // 99
           Method m2 = std.getDeclaredMethod("setGrade", int.class);
           m2.setAccessible(true);
           m2.invoke(student, 1);
           System.out.println(student.getGrade()); // 1
   
           //Person p = Person.class.newInstance(); 报错，没有无参构造器
           //System.out.println(p.getName());
           Constructor constructor = Person.class.getConstructor(String.class);
           Person p = (Person) constructor.newInstance("Li Si");
           System.out.println(p.getName()); // Li Si
   
           // 获取父类Class实例
           Class cp = student.getClass().getSuperclass();
           
       }
   
   }
   
   class Person {
   
       private String name;
   
       public Person(String name){
           this.name = name;
       }
   
       public String getName(){
           return name;
       }
   
       private void setName(String name) {
           this.name = name;
       }
   }
   
   class Student extends Person {
   
       private int score;
       private int grade;
   
       public Student(String name) {
           super(name);
       }
   
       public void setScore(int score) {
           this.score = score;
       }
   
       public int getScore() {
           return score;
       }
   
       private void setGrade(int grade) {
           this.grade = grade;
       }
   
       public int getGrade() {
           return grade;
       }
   }
   ```



##### 3. 动态代理

动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，并没有什么黑魔法。在运行状态中，需要代理的地方，动态地创建一个Proxy，用完之后，就会销毁，这样可以避免Proxy 角色的 class 在系统中冗余。

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Main {
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if (method.getName().equals("morning")) {
                    System.out.println("Good morning, " + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(
            Hello.class.getClassLoader(), // 传入ClassLoader
            new Class[] { Hello.class }, // 传入要实现的接口
            handler); // 传入处理调用方法的InvocationHandler
        hello.morning("Bob");
    }
}

interface Hello {
    void morning(String name);
}
```

在运行期动态创建一个`interface`实例的方法如下：

1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；

2. 通过`Proxy.newProxyInstance()`

   创建`interface`实例，它需要3个参数：

   1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`；
   2. 需要实现的接口数组，至少需要传入一个接口进去；
   3. 用来处理接口方法调用的`InvocationHandler`实例。

3. 将返回的`Object`强制转型为接口。



##### 4. 泛型

多态算是一种泛化机制，可以将方法的参数类型设为基类或接口，则由基类派生出来的类或任何实现了该接口的类都能够满足该方法。泛型就是指适用于许多类型，利用泛型可以编写更通用的代码。

泛型可以理解为一种模板技术，例如`ArrayList<T>`，然后在代码中为用到的类创建对应的`ArrayList<类型>`：由编译器针对类型作检查：

```java
strList.add("hello"); // OK
String s = strList.get(0); // OK
strList.add(new Integer(123)); // compile error!
Integer n = strList.get(0); // compile error!
```

Java语言的泛型实现方式是擦拭法（Type Erasure）。所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。

```java
// 编译器
public class Tuple<A, B> {
	public final A first;
	public final B second;
	public Tuple(A a, B b) {first = a; second = b; }
	public String toString() {
		return "(" + first + ", " + second + ")";
	}
}

// 虚拟机
public class Tuple {
	public final Object first;
	public final Object second;
	public Tuple(Object a, Object b) {first = a; second = b; }
	public String toString() {
		return "(" + first + ", " + second + ")";
	}
}
```

泛型的通用匹配：

`<T extends xxx>`表示接受`xxx`及`xxx`的子类

`<? super xxx>`表示接受`xxx`及`xxx`的父类

Java泛型局限：
- `<T>`不能是基本类型
- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`
- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`
- 不能实例化T类型，例如：`new T()`

泛型数组：`T[] objs = (T[])new Object[n]`







