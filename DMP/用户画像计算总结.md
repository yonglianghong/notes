### 用户画像计算总结

##### 画像的主体

1. 单个用户：u_id

2. 人群

   a) 即时生成：基于现有的标签数据，筛选标签，通过标签之间的组合计算，生成人群

   b) u_id文件：即u_id集合

##### 画像的指标

1. 占比：某个标签命中的数量/做画像的人群中在总体中有此类标签的人数
2. TGI ：Target Group Index，目标群体指数，反映该用户群在某兴趣点上与总体的差异程度
3. 行为特征：比如7日活跃覆盖度等也可以转化成标签参与计算

##### 画像数据输入

1. 单个用户：IDFA/IMEI md5?

2. 人群：

   a) 即时生成：筛选的tags，及crowd生成规则

   b) u_id文件

##### 画像数据流程

![](https://hong-md.oss-cn-beijing.aliyuncs.com/md/2019-06-17-%E7%94%BB%E5%83%8F%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.jpg)

a) 生成全量用户标签数据

b) 基于全量用户标签数据，生成（更新）全量用户编码表和生成全量标签bitmap，将全量用户标签数据写入kv库

c) 如果是查询人群画像，则先生成人群的bitmap，这里分为两种，一种是基于u_id集合生成crowd bitmap，一种是基于现有标签，通过标签组合计算生成crowd bitmap，再进行画像计算，返回人群画像结果

d) 如果是查询单个用户画像，则直接查询kv库，返回画像结果

> 用户编码，最好采用一次编码，更新追加的方式来减少计算量
>
> (与每天重复编码相比)

##### 画像计算难点

1. 生成bitmap

   a) container初始化容量和类型自定义

   ![](https://hong-md.oss-cn-beijing.aliyuncs.com/md/2019-06-17-RoaringBitmap.jpg)

   如上图所示，RoaringBitmap实际上包含的是一个RoaringArray，而RoaringArray由两部分组成，short[]保存公共key，Container[]保存value值，而Container[]有三种：ArrayContainer、BitmapContainer、RunContainer。

   ArrayContainer直接用数组存储value值，最大长度为4096，即如果超过4096个值就自动转为BitmapContainer，占用的存储空间由长度决定，最大8KB。

   BitmapContainer则是采用bitmap的方式存储value值，存储空间固定为8KB，存储元素个数为64*1024=65536个。

   RunContainer则是将BitmapContainer采用压缩算法进行压缩生成的，存储空间跟数据的连续性关系比较大，范围从4Byte~128KB。

   

   在创建RaringBitmap时，默认的Containner[]长度为4，以及底层的Container会经过各种转换，因此可以根据实际数据特征，在初始化时进行一些自定义：

   ```java
       /**
        * 自定义container初始化容量,在创建roaringbitmap对象时,就创建其底层container[]中的对象,并且直接创建bitmapContainer对象
        * 1. 默认容量为4
        * 2. 默认arrayContainer -> bitmapContainer -> runContainer
        * @param dat int or int[]
        * @return roaringbitmap
        */
       public static RoaringBitmap bitmapOf(int INITIAL_CAPACITY, final int... dat) {
           Container[] container = new Container[INITIAL_CAPACITY];
           RoaringArray highLowContainer = new RoaringArray(new short[INITIAL_CAPACITY], container, 0);
           for (int i = 0; i < INITIAL_CAPACITY; i++) {
               final BitmapContainer newac = new BitmapContainer();
               highLowContainer.setContainerAtIndex(i, newac);
           }
           final RoaringBitmap ans = new RoaringBitmap(highLowContainer);
           ans.add(dat);
           ans.runOptimize();
           return ans;
       }
   ```

   b) 两阶段聚合，并且在聚合过程中设置array buffer

   ```scala
   class BitMapOptimizeUDAF extends UserDefinedAggregateFunction {
   
     val CACHE_SIZE = 10000L
     override def inputSchema: StructType = {
       StructType(StructField("index",IntegerType)::Nil)
     }
   
     /**
       * commonArray用来逐渐累加
       * bitMapArray当commonArray满了的时候才存
       * @return
       */
     override def bufferSchema: StructType = {
       StructType(StructField("commonArray", ArrayType(IntegerType))::StructField("bitMapArray", BinaryType)::Nil)
     }
   
     override def dataType: DataType = BinaryType
   
     override def deterministic: Boolean = true
   
     override def initialize(buffer: MutableAggregationBuffer): Unit = {
       val r = new RoaringBitmap
       buffer(0) = Seq[Int]()
       buffer(1) = RoaringUtil.roaringSerialize(r)
   
     }
   
     override def update(buffer: MutableAggregationBuffer, input: Row): Unit = {
       val seq = buffer.getAs[Seq[Int]](0) :+ input.getAs[Int](0)
       if (seq.size <= CACHE_SIZE) {
         buffer(0) = seq
       }else {
         //取出roaring,将数组同步进去
         val array = buffer.getAs[Array[Byte]](1)
         val r = RoaringUtil.roaringDeserialize(array)
         seq.foreach(r.add)
         buffer(1) = RoaringUtil.roaringSerialize(r)
         buffer(0) = Seq[Int]()
       }
     }
   
     override def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = {
       val s1 = buffer1.getAs[Seq[Int]](0)
       val s2 = buffer2.getAs[Seq[Int]](0)
       val seq = s1 ++ s2
   
       val r1 = RoaringUtil.roaringDeserialize(buffer1.getAs[Array[Byte]](1))
       val r2 = RoaringUtil.roaringDeserialize(buffer2.getAs[Array[Byte]](1))
       //先merge 两个Buffer的bitmap部分
       r1.or(r2)
       //如果array部分超过了长度,就把array缓存的数据保存到bitmap中
       if (seq.size <= CACHE_SIZE) {
         buffer1(0) = seq
       } else {
         seq.foreach(r1.add)
         buffer1(0) = Seq[Int]()
       }
   
       buffer1(1) = RoaringUtil.roaringSerialize(r1)
     }
   
     override def evaluate(buffer: Row): Any = {
       val seq = buffer.getAs[Seq[Int]](0)
       //如果不为空,那么还需把剩余的数据merge到bitmap中去
       if (seq.nonEmpty) {
         val r1 = RoaringUtil.roaringDeserialize(buffer.getAs[Array[Byte]](1))
         seq.foreach(r1.add)
         RoaringUtil.roaringSerialize(r1)
       }else {
         //为空的话直接返回,避免序列化
         buffer.getAs[Array[Byte]](1)
       }
   
     }
   }
   ```

2. 减少reduce

   a) 生成总体的tagtype标签

   > tgi = (crowd_tag_uv / crowd_tagtype_uv) / (total_tag_uv / total_tagtype_uv)
   >
   > crowd_tag_uv：人群中某个tag命中的人数
   >
   > crowd_tagtype_uv：人群中某类tagtype命中的人数
   >
   > total_tag_uv：总体中某个tag命中的人数
   >
   > total_tagtype_uv：总体中某类tagtype命中的人数

   

   crowd_tag_bitmap = (crowd_bitmap) n (total_tag_bitmap)

   如果基于crowd_tag_bitmap来生成crowd_tagtype_bitmap，则需要进行reduce，与大量序列化反序列化的操作，所以可以在数据准备阶段生成total_tagtype_bitmap，这样：

   crowd_tagtype_bitmap = (crowd_bitmap) n (total_tagtype_bitmap)

   b) 使用广播

   将crowd_bitmap、crowd_tagtype_bitmap进行广播，这样整个画像计算就可以直接在各个partition内全部由map计算完成，尽可能减少reduce。

3. bitmap表达式计算

   标签组合运算可以理解为集合运算，基于集合运算规则生成人群，可以将这一计算过程抽象为表达式计算。第一步是解析规则表达式，第二步如果底层是bitmap，那就是基于bitmap的交并差运算：

   ```scala
   trait Expression[T] extends Serializable {
   
     def reduce(aggregator: SetAggregator[T]): T
   
   }
   
   class PredicateExpression[T](t: T) extends Expression[T] {
     def getValue = t
     override def reduce(aggregator: SetAggregator[T]): T = t
   }
   
   class SetExpression[T](setOperator: SetOperator) extends Expression[T]{
   
     var childExpression:List[Expression[T]] = List.empty[Expression[T]]
   
     def getInvolvedItem: List[T] = {
       childExpression.flatMap{
         case e1 : PredicateExpression[T] => List(e1.getValue)
         case e2 : SetExpression[T] => e2.getInvolvedItem
       }
     }
   
     def addExpression(expression: Expression[T]) ={
       childExpression = expression +: childExpression // 倒序遍历 所以添加在头部
     }
   
     def getSetOperator = setOperator
   
     def addAll(setExpressionList: List[Expression[T]]) ={
       childExpression = childExpression ::: setExpressionList
     }
   
     def transform[B](f:T => B): SetExpression[B] = {
       val transformedExpression = new SetExpression[B](setOperator)
       transformedExpression.addAll(
         childExpression.map({
           case e1 : PredicateExpression[T] => new PredicateExpression[B](f(e1.getValue))
           case e2 : SetExpression[T] => e2.transform(f)
         })
       )
       transformedExpression
     }
   
     def statByCondition(f: T => RoaringBitmap): RoaringBitmap = {
       transform[RoaringBitmap](f).reduce(new roaringbitmapAggregator)
     }
   
     override def reduce(aggregator: SetAggregator[T]): T = {
       this match {
         case e1: PredicateExpression[T] => e1.getValue
         case e2: SetExpression[T] => {
           val childResult = childExpression.map(_.reduce(aggregator))
           setOperator match {
             case SetOperator.AND => aggregator.and(childResult)
             case SetOperator.OR => aggregator.or(childResult)
             case SetOperator.NOT => aggregator.not(childResult.head, childResult.tail)
           }
         }
       }
     }
   
   }
   
   
   object SetOperator extends Enumeration {
   
     type SetOperator = Value
     val AND = Value("and")
     val OR = Value("or")
     val NOT = Value("not")
   
   }
   
   trait SetAggregator[T]{
     def and(a:T, b:T): T
     def or(a:T, b:T): T
     def not(a:T, b:List[T]): T
   
     def and(list: List[T]): T = {
       list.reduce(and)
     }
   
     def or(list: List[T]): T = {
       list.reduce(or)
     }
   }
   
   class roaringbitmapAggregator extends SetAggregator[RoaringBitmap]{
     def and (a: RoaringBitmap, b:RoaringBitmap): RoaringBitmap = {
       RoaringUtil.andList(List(a, b))
     }
   
     def or (a:RoaringBitmap, b:RoaringBitmap): RoaringBitmap = {
       RoaringUtil.orList(List(a, b))
     }
   
     def not (a:RoaringBitmap, b:List[RoaringBitmap]): RoaringBitmap = {
       RoaringUtil.andNotList(a, b)
     }
   }
   
   @transient
   object SetExpression {
   
     def main(args: Array[String]) {
       val map = Map("a" -> RoaringUtil.bitmapOf(1,2,3), "b" -> RoaringUtil.bitmapOf(1), "c" -> RoaringUtil.bitmapOf(3), "d" -> RoaringUtil.bitmapOf(2,3))
   //    val setStr = "(a∪b)-(d∩c)"
   //    val setStr = "b"
       val setStr = "b∪c∩d"
       setStr.foreach(v => println(v, v.toInt))
       val setExpression = fromSetExpression(setStr, setStr.length - 1)._1
       val r = setExpression.statByCondition(v => map.get(v).get)
       println(r.toString)
     }
   
     def fromSetExpression(setExpressionStr: String, start: Int): (SetExpression[String], Int) = {
       var l: SetExpression[String] = null // 保存最终的express
       var h: SetExpression[String] = null // 记录一次调用中,得到的expression
       var jump = setExpressionStr.length // 判断在一次调用中,是否结束
       var cur = 0 // 在整个setExpressionStr倒序遍历的位置
       var lastIndex = start
       val buffer = new StringBuffer()
   
       for(i <- start to 0 by -1 if i < jump){
         val c = setExpressionStr.charAt(i)
         // a~z _
         if(c == 95 || c >= 97 && c <= 122){
           buffer.append(c)
         }else if (c == ')'){
           val (setExpression, newStart) = fromSetExpression(setExpressionStr, i - 1)
           if( l != null)
             l.addExpression(setExpression)
           else
             h = setExpression
           jump = newStart
         }else if (c == '('){
           jump = 0
           cur = i
         }else if (c == '∪' || c == '∩' || c == '-'){
           if (l == null){
             if (c == '∪')
               l = new SetExpression[String](SetOperator.OR)
             else if ( c == '∩')
               l = new SetExpression[String](SetOperator.AND)
             else{
               l = new SetExpression[String](SetOperator.NOT)
             }
             if(h != null)
               l.addExpression(h)
             lastIndex = i
           }else{
             if ((c == '∪' && l.getSetOperator == SetOperator.AND) || (
               (c == '∩' || c == '-') && l.getSetOperator == SetOperator.OR)){
               buffer.setLength(0)
               //如果有连续的交并差 将当前位置传入参数,下一个迭代从当前位置继续遍历,返回的值为剩下所有字符生成的 SetExpression
               val (setExpression, newStart) = fromSetExpression(setExpressionStr, lastIndex - 1)
               l.addExpression(setExpression)
               jump = newStart - 1
             }else
               lastIndex = i
           }
   
           if(buffer.length() > 0){
             l.addExpression(new PredicateExpression[String](buffer.reverse().toString))
             buffer.setLength(0)
           }
         }
       }
   
       if (buffer.length() > 0){
         if(l == null){
           l = new SetExpression[String](SetOperator.AND)
         }
         l.addExpression(new PredicateExpression[String](buffer.reverse().toString))
         buffer.setLength(0)
       }
   
       if (l == null && h != null)
         (h, cur)
       else
         (l, cur)
     }
   
   }
   ```

4. 一次编码，增量更新

   a) 维护一个用户与编码的对应关系表，将活跃的用户排在前面，这样有利于计算？（考虑活跃用户就得改变编码了，周期更新）

   b) 将用户标签表与用户编码表join的时候，存在问题？

   c) 生成bitmap增量更新





