##### 0. 前言

排序就是将一组元素按照某种逻辑顺序重新排列的过程。Java中的元素通常都是对象，逻辑顺序主要是通过`Comparable`接口来实现的。



排序算法类模板：

```java
public class Example {

    public static void sort(Comparable[] a) {}

    // 辅助函数less()
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    // 辅助函数exch()
    private static void exch(Comparable[] a, int i, int j) {
        Comparable tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.print(a[i]+ " "); // 单行打印
        System.out.println();
    }

    // 检查是否有序
    private static boolean isSorted(Comparable[] a) {
        for(int i = 1; i < a.length; i++){
            if(less(a[i-1], a[i]))
                return false;
        }
        return true;
    }

}
```



算法运行性能：

- 运行时间：主要关注元素 *比较* 和 *交换* 的次数，对不交换元素的算法，关注 *访问数组的次数*。
- 内存使用：*原地排序* 是指只需要消耗函数调用所需的栈及固定实例（比如exch()中的tmp、指针变量i,j等）的内存空间。其他算法可能还需要额外空间存储数组副本。



数据类型：

Java基本类型的包装类及常用类`String`、`File`、`Date`都实现了`Comparable`接口。

自定义数据类型时，只要实现`Comparable`接口，即实现一个`compareTo`方法来定义目标类型对象的 *自然顺序* 就可以排序。给对象定义顺序。通过Comparator接口可以更灵活的定义多种顺序，并且在排序的时候传入Comparator。



##### 1. 初级排序

###### 1. 选择排序

选择一组元素中最小（大）的，与第一个（最后一个）交换，如此反复，直到整个有序。

```java
public class Selection {

    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            // 将a[i]和a[i+1...N-1]中最小的元素交换
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min]))
                    min = j;
            }
            exch(a, i, min); // 如果min=0，或当i=N-1（此时min=i）时，都会执行exch
        }
    }

}
```

内循环只是比较当前元素与目前已知的最小元素（以及当前索引+1和检查代码是否越界），外循环控制交换。

- 对于长度为N的数组，选择排序需要大约$N^2/2$次比较，和$N$次交换。

- 运行时间和输入无关，即与数据的初始状态（是否有序）无关。

- 数据交换的次数和数组的大小是 *线性* 关系。



###### 2. 插入排序

将元素插入到有序序列中的合适位置。

```java
public class Insertion {

    public static void sort(Comparable[] a) {
        int N = a.length;
        for(int i = 1; i < N; i++){
            // 将a[i]插入到a[0]...a[i-2]a[i-1]中
            for(int j = i; j > 0 && less(a[j], a[j-1]); j--){
                    exch(a, j, i);
            }
        }
    }

}
```

插入排序与元素的初始顺序有关，对于长度为N且不重复的数组：

- 最坏：即初始逆序，需要$N^2/2$次比较，和$N^2/2$次交换；
- 平均：需要$N^2/4$次比较，和$N^2/4$次交换；`???`
- 最好：即初始正序，需要$N-1$次比较，$0$次交换。

比较的总次数=交换的总次数 + 一个额外的项。最坏的情况下，可忽略不计；最好的情况下，这一项是$N-1$。



部分有序：

*倒置* 是指数组中两个顺序颠倒的元素。比 如 E X A M P L E 中有 11 对倒置：E-A、 X-A、 X-M、 X-P、 X-L、 X-E、 M-L、 M-E、 P-L、 P-E以及 L-E。

插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的 数量，小于等于倒置的数量加上数组的大小再减一。



选择排序 vs 插入排序：

1. 当前索引左边的元素都是有序的，但选择排序是确定不变的，而插入排序还可能被移动（为更小的元素腾位置）；
2. 交换操作`exch()`在选择排序中写在外循环的，而插入排序中是在内循环里的；
3. 插入排序不会访问当前索引右侧的元素，而选择排序不会访问当前索引左侧的元素；
4. 从可视化的轨迹图中可以看到，因为插入排序不会移动比被插入的元素更小的元素，它所需的比较次数平均只有选择排序的一半;
5. 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比应该是一个较小的常数。



###### 3. 希尔排序

基于插入排序的快速排序：

- 插入排序只会交换相邻的元素，因此元素只能一点点地从数组一端移动到另一端；
- 插入排序的效率与数组的初始状态有关；
- 先交换不相邻的元素，让数组整体更有序，最终用插入排序将更有序的数组排序；
- 希尔排序的思想是使数组中任意间隔为 *h* 的元素都是有序的。

*h* 有序数组，就是 *h* 个互相独立的有序数组编织在一起组成的一个数组。

实现希尔排序的方法：

1. 对于每个h，用插入排序将h个子数组独立地排序；
2. 从h索引开始，比如a[0]和a[h]，如果a[0]较大，则交换，这样就只需要将插入排序的代码的移动距离从1改为h即可，转化为了一个类似于插入排序但使用不同增量的过程。

希尔排序，权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。

```java
public class Shell {

    public static void sort(Comparable[] a) {
        int h = 1;
        int N = a.length;
        // 从 N/3 开始递减至 1
        while (h < N / 3) h = 3 * h + 1; // h = 1, 4, 13, 40, 121, 364, ...
        while (h >= 1) {
            for (int i = h; i < N; i++) { // 从h开始
                for (int j = i; j > h - 1 && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            h /= 3;
        }
    }
    
}
```

注：mac上测试Shell-sort比Insertion-sort慢。

运行性能：

- 运行时间达不到平方级别，比较次数和 $N^{2/3}$ 成正比；
- 使用递增序列 1, 4, 13, 40, 121, 364… 的希尔排序所需的比较次数不会超出 N 的若干倍乘以递增序列的长度。`???`



##### 2. 归并排序

将两个有序的数组合并成一个更大的有序数组。

###### 1. 原地归并抽象

将所有元素复制到一个辅助数组中，再把归并的结果放回原数组中，这样类似实现了原地归并。

```java
public static void merge(Comparable[] a, int lo, int mid, int hi){
    // 将a[lo..mid] 和 a[mid+1..hi] 归并
    int i = lo, j=mid+1;

   for(int k = lo; k <= hi; k++) // 将a[lo..hi]复制到aux[lo..hi]
       aux[k] = a[k];

    for(int k = lo; k <= hi; k++){ // 归并回a[lo..hi]
        if(i>mid) a[k] = aux[j++];
        else if (j>hi) a[k] = aux[i++];
        else if(less(aux[j], aux[i])) a[k] = aux[j++];
        else a[k] = aux[i++];
    }
}
```



###### 2. 自顶向下

归并排序是算法设计中分治思想的典型应用：

```java
public class Merge {

    private static Comparable[] aux; // 归并所需的辅助数组

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = (lo + hi) / 2;
        sort(a, lo, mid); // 左半部分
        sort(a, mid + 1, hi); // 右半部分
        merge(a, lo, mid, hi);
    }

}
```

1. 对数组 a[lo..hi] 进行排序，先将它分为 a[lo..mid] 和 a[mid+1..hi] 两部分，通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果；

2. `sort()`方法的作用在于安排多次`merge()`方法调用的正确顺序。



归并排序子数组依赖树：

这棵树有$n$层，对于从$0$到$n-1$的任意$k$，自顶向下的第$k$层有$2^k$个子数组，每个数组的长度为$2^{n-k}$，归并最多需要$2^{n-k}$次比较（即数组长度N）。

因此每层的比较次数为 $2^k×2^{n-k}=2^n$ ，$n$层总共为$n2^n= NlgN$。



对于长度为 N 的任意数组，自顶向下的归并排序：

1. 需要$½NlgN$至$NlgN$次比较；
2. 最多需要访问数组$6NlgN$次

每次归并最多需要访问数组6N次（2N次用来复制，2N次用来将排好序的元素移动回去， 另外最多比较2N次）。



改进：

1. 对小规模子数组使用插入排序；
2. 归并前进行判断：如果a[mid]<=a[mid+1]，则认为数组已经有序；
3. 不复制元素：输入数组 $ \overset{排序}{\rightarrow}$辅助数组，辅助数组 $\overset{排序}{\rightarrow}$ 输入数组



###### 3. 自底向上

首先进行两两归并（将每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组），再是八八的归并，一直持续下去。

- 子数组：sz = 1，sz = sz+sz，sz < N，即1, 2, 4, 8, 16, ...

- 子数组索引: lo = 0, lo = lo + sz + sz, 即0, 2sz-1, ...，merge时的索引为(lo, lo+sz-1, lo+sz+sz-1)

```java
public class MergeBU {

    private static Comparable[] aux; // 归并所需的辅助数组

    public static void sort(Comparable[] a) {
        // 进行lgN次两两归并
        int N = a.length;
        aux = new Comparable[a.length];
        for (int sz = 1; sz < N; sz = sz + sz) // sz子数组大小
            for (int lo = 0; lo < N - sz; lo += sz + sz) // lo子数组索引
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
    }

}
```

对于长度为$N$的任意数组，自底向上的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

处理一个数组的遍数正好是$lgN$（即$2^n ≤N≤2^{n+1}$中的n）。每一遍会访问数组$6N$次，比较次数在$N/2$和$N$之间。

当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。



自顶向下 vs 自底向上：

- 自底向上的归并排序比较适合用 *链表* 组织的数据。只需要重新组织链表链接就能将链表 *原地* 排序。

- 用自顶向下或是自底向上的方式实现任何 *分治* 类的算法都很自然。

- 自顶向下 -> 化整为零（递归解决）

- 自底向上 -> 循序渐进



###### 4. 排序算法复杂度

没有任何基于比较的算法能够保证使用少于 $lg(N!)\sim NlgN$次比较将长度为$N$的数组排序。

任意基于比较的排序算法都对应着一棵高 $h$ 的比较树，其中$N! ≤叶子结点的数量≤ 2^h$。（叶子结点表示一种排列顺序，从根结点到叶子结点每一条路径都对应着算法在建立叶子结点所示的顺序时进行的所有比较。$N$个不同的主键会有$N!$种不同的排列，高度为 $h$ 的二叉树最多只可能有 $2^h$ 个叶子结点。）

$h$ 的值就是最坏情况下的比较次数，因此对不等式的两边取对数即可得到任意算法的比较次数至少是$lgN!$，根据斯特灵公式对阶乘函数的近似可得 $lgN! \sim NlgN$。

归并排序是一种渐进最优的基于比较排序的算法。即归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 $\sim NlgN$。



##### 3. 快速排序

快速排序是一种分治思想的排序算法，它将一个数组分成两个子数组，将两部分独立地排序。与归并排序不同之处在于：归并排序的递归调用发生在处理整个数组之前，而快速排序递归调用发生在处理整个数组之后。



快排算法：
1. 选取切分元素，将数组切分为两个子数组；
2. 再递归调用对两个子数组进行排序；
3. 当两个子数组有序时，整个数组就有序。（这是与归并排序很大的不同）



切分算法：

1. 选择a[lo]为切分元素；
2. 用指针i从左向右开始扫描，找到一个大于等于a[lo]的元素；
3. 用指针j从右向左开始扫描，找到一个小于等于a[lo]的元素；
4. 交换i与j位置的元素；
5. 当i与j相遇时（i==j），交换切分元素a[lo]与a[j]，返回此时切分元素位置j；



快速排序切分示意图：

<div style="text-align: center;"> <img src="https://raw.githubusercontent.com/yonglianghong/my-drive/md/img/Algorithm.Sort.Quick.Partition.jpg" width = "30%" height = "30%"/> </div>



切分函数：

```java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo + 1, j = hi;
    Comparable v = a[lo];

    while (true) {
        while (less(a[i++], v)) // 从左向右扫描，直到找到较大的
            if (i > hi) break; // 防止越界，如果a[lo]最大
        while (less(v, a[j++])) ; // 从右向左扫描，直到找到较小的
        exch(a, i, j); // 交换
        if (i >= j) // 如果lo = hi，则此时i > j；a[lo]为最小的元素，也会出现i > j
            break;
    }
    exch(a, lo, j);
    return j;

}
```



整体代码：
```java
public class Quick {

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1); // 将左半部分a[lo...j-1]排序
        sort(a, j + 1, hi); // 将右半部分a[j+1...hi]排序
    }

}
```

注意：
1. 原地切分：不利用辅助数组
2. 别越界：如果切分元素是最小或最大，此时指针i或j将会移动到两端
3. 保持随机：排序前先`shuffle()`或随机选择切分元素
4. 终止循环
5. 终止递归



性能：
- 快速排序的最好情况是每次都正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的$C_{N} = 2C_{N/2} + N$公式。$2C_{N/2}$表示将两个子数组排序的成本，$N$表示用切分元素和所有数组元素进行比较的成本。这个递归公式的解 $C N \sim N lgN$。
- 将长度为 $N$ 的无重复数组排序，快速排序平均需要 $\sim 2NlnN$ 次比较（以及 1/6 的交换）。注 意 到 $2NlnN ≈ 1.39NlgN$，也就是说平均比较次数只比最好情况多39%。
- 快速排序最多需要约 $N^2/2$ 次比较，但随机打乱数组能够预防这种情况。(切分元素始终最小或最大会出现)



改进：
1. 小数组用插入排序：`if (lo + M >= hi) { Insertion.sort(a, lo, hi); return; }`
2. 三取样切分：取样大小设为3，并以大小居中的元素进行切分，还可以将取样元素放在末尾作为“哨兵”来去掉`partition()`中的数组边界测试。（如果选择a[lo]作为切分元素，则a[lo]本身则相当于哨兵。）
3. 三向切分：将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。



Dijkstra解法（荷兰国旗）：
1. 从左到右遍历数组，三个指针，lt、i、gt，lt使得a[lo...lt-1]中的元素都小于v，i使得a[lt...i-1]中的元素都等于v，a[i...gt]中的元素未知，gt使得a[gt+1...hi]中的元素都大于v
2. 一开始v=a[lo],lt=lo,i=lo+1,gt=hi
	- a[i]<v，将a[i]与a[lt]交换，将lt和i加1；
	- a[i]>v，将a[i]与a[gt]交换，将gt减一；
	- a[i]=v，将i加1。
3. 这些操作都会保证数组元素不变且缩小gt-i的值（这样循环才会结束）。

```java
public class Quick3Way {

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];

        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) exch(a, i++, lt++); // why i++? 因为此时a[i]=v，所以直接将i+1（如果这里不对i+1，再一次循环也会对i+1）
            else if (cmp > 0) exch(a, i, gt--);
            else i++;
        } // 现在 a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]成立
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```

对于只有若干不同主键的随机数组，归并排序的时间复杂度是线性对数的，而三向切分快速排序则是线性的。

对主键概率分布进行分析：

给定包含 $k$ 个不同值的 $N$ 个主键，对于从 1 到 $k$ 的每个 $i$ ，定义 $f_{i}$ 为第 i 个主键值出现的次数， 则概率 $p_{i}$ 为 $f_{i}/N$。所有主键的`香农信息量`：$H=-(p1lgp1+p2lgp2+...+pklgpk)$

- 基于比较的排序算法至少需要 $NH-N$ 次比较（ $H$ 即香农信息量）;
- 对于大小为 $N$ 的数组，三向切分的快速排序需要 $\sim(2ln2)NH$ 次比较;
- 当所有的主键值均不重复时有 $H=lgN$ （所有主键的概率均为 $1/N$ ）

三向切分的最坏情况正是所有主键均不相同，当存在重复主键时，它的性能就会比归并排序好得多。对于任意分布的输入，最优的基于比较的算法平均所需的比较次数和三向切分的快速排序平均所需的比较次数相差范围只在常数因子范围内。

对于包含大量重复元素的数组，它将排序时间从线性对数降低到了线性级别（这和元素的排序顺序没关系，因为排序之前会将其打乱以避免最坏情况）。元素的概率分布决定了信息量的大小，没有基于比较的排序算法能够用少于信息量决定的比较次数完成排序。



