##### `0. 前言

排序就是将一组元素按照某种逻辑顺序重新排列的过程。Java中的元素通常都是对象，逻辑顺序主要是通过`Comparable`接口来实现的。



排序算法类模板：

```java
public class Example {

    public static void sort(Comparable[] a) {}

    // 辅助函数less()
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    // 辅助函数exch()
    private static void exch(Comparable[] a, int i, int j) {
        Comparable tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.print(a[i]+ " "); // 单行打印
        System.out.println();
    }

    // 检查是否有序
    private static boolean isSorted(Comparable[] a) {
        for(int i = 1; i < a.length; i++){
            if(less(a[i-1], a[i]))
                return false;
        }
        return true;
    }

}
```



算法运行性能：

- 运行时间：主要关注元素 *比较* 和 *交换* 的次数，对不交换元素的算法，关注 *访问数组的次数*。
- 内存使用：*原地排序* 是指只需要消耗函数调用所需的栈及固定实例（比如exch()中的tmp、指针变量i,j等）的内存空间。其他算法可能还需要额外空间存储数组副本。



数据类型：

Java基本类型的包装类及常用类`String`、`File`、`Date`都实现了`Comparable`接口。

自定义数据类型时，只要实现`Comparable`接口，即实现一个`compareTo`方法来定义目标类型对象的 *自然顺序* 就可以排序。给对象定义顺序。通过Comparator接口可以更灵活的定义多种顺序，并且在排序的时候传入Comparator。



##### 1. 初级排序

###### 1. 选择排序

选择一组元素中最小（大）的，与第一个（最后一个）交换，如此反复，直到整个有序。

```java
public class Selection {

    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            // 将a[i]和a[i+1...N-1]中最小的元素交换
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min]))
                    min = j;
            }
            exch(a, i, min); // 如果min=0，或当i=N-1（此时min=i）时，都会执行exch
        }
    }

}
```

内循环只是比较当前元素与目前已知的最小元素（以及当前索引+1和检查代码是否越界），外循环控制交换。

- 对于长度为N的数组，选择排序需要大约$N^2/2$次比较，和$N$次交换。

- 运行时间和输入无关，即与数据的初始状态（是否有序）无关。

- 数据交换的次数和数组的大小是 *线性* 关系。



###### 2. 插入排序

将元素插入到有序序列中的合适位置。

```java
public class Insertion {

    public static void sort(Comparable[] a) {
        int N = a.length;
        for(int i = 1; i < N; i++){
            // 将a[i]插入到a[0]...a[i-2]a[i-1]中
            for(int j = i; j > 0 && less(a[j], a[j-1]); j--){
                    exch(a, j, i);
            }
        }
    }

}
```

插入排序与元素的初始顺序有关，对于长度为N且不重复的数组：

- 最坏：即初始逆序，需要$N^2/2$次比较，和$N^2/2$次交换；
- 平均：需要$N^2/4$次比较，和$N^2/4$次交换；`???`
- 最好：即初始正序，需要$N-1$次比较，$0$次交换。

比较的总次数=交换的总次数 + 一个额外的项。最坏的情况下，可忽略不计；最好的情况下，这一项是$N-1$。



部分有序：

*倒置* 是指数组中两个顺序颠倒的元素。比 如 E X A M P L E 中有 11 对倒置：E-A、 X-A、 X-M、 X-P、 X-L、 X-E、 M-L、 M-E、 P-L、 P-E以及 L-E。

插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的 数量，小于等于倒置的数量加上数组的大小再减一。



选择排序 vs 插入排序：

1. 当前索引左边的元素都是有序的，但选择排序是确定不变的，而插入排序还可能被移动（为更小的元素腾位置）；
2. 交换操作`exch()`在选择排序中写在外循环的，而插入排序中是在内循环里的；
3. 插入排序不会访问当前索引右侧的元素，而选择排序不会访问当前索引左侧的元素；
4. 从可视化的轨迹图中可以看到，因为插入排序不会移动比被插入的元素更小的元素，它所需的比较次数平均只有选择排序的一半;
5. 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比应该是一个较小的常数。



###### 3. 希尔排序

基于插入排序的快速排序：

- 插入排序只会交换相邻的元素，因此元素只能一点点地从数组一端移动到另一端；
- 插入排序的效率与数组的初始状态有关；
- 先交换不相邻的元素，让数组整体更有序，最终用插入排序将更有序的数组排序；
- 希尔排序的思想是使数组中任意间隔为 *h* 的元素都是有序的。

*h* 有序数组，就是 *h* 个互相独立的有序数组编织在一起组成的一个数组。

实现希尔排序的方法：

1. 对于每个h，用插入排序将h个子数组独立地排序；
2. 从h索引开始，比如a[0]和a[h]，如果a[0]较大，则交换，这样就只需要将插入排序的代码的移动距离从1改为h即可，转化为了一个类似于插入排序但使用不同增量的过程。

希尔排序，权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。

```java
public class Shell {

    public static void sort(Comparable[] a) {
        int h = 1;
        int N = a.length;
        // 从 N/3 开始递减至 1
        while (h < N / 3) h = 3 * h + 1; // h = 1, 4, 13, 40, 121, 364, ...
        while (h >= 1) {
            for (int i = h; i < N; i++) { // 从h开始
                for (int j = i; j > h - 1 && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            h /= 3;
        }
    }
    
}
```

注：mac上测试Shell-sort比Insertion-sort慢。

运行性能：

- 运行时间达不到平方级别，比较次数和 $N^{2/3}$ 成正比；
- 使用递增序列 1, 4, 13, 40, 121, 364… 的希尔排序所需的比较次数不会超出 N 的若干倍乘以递增序列的长度。`???`



##### 2. 归并排序

将两个有序的数组合并成一个更大的有序数组。

###### 1. 原地归并抽象

将所有元素复制到一个辅助数组中，再把归并的结果放回原数组中，这样类似实现了原地归并。

```java
public static void merge(Comparable[] a, int lo, int mid, int hi){
    // 将a[lo..mid] 和 a[mid+1..hi] 归并
    int i = lo, j=mid+1;

   for(int k = lo; k <= hi; k++) // 将a[lo..hi]复制到aux[lo..hi]
       aux[k] = a[k];

    for(int k = lo; k <= hi; k++){ // 归并回a[lo..hi]
        if(i>mid) a[k] = aux[j++];
        else if (j>hi) a[k] = aux[i++];
        else if(less(aux[j], aux[i])) a[k] = aux[j++];
        else a[k] = aux[i++];
    }
}
```



###### 2. 自顶向下

归并排序是算法设计中分治思想的典型应用：

```java
public class Merge {

    private static Comparable[] aux; // 归并所需的辅助数组

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = (lo + hi) / 2;
        sort(a, lo, mid); // 左半部分
        sort(a, mid + 1, hi); // 右半部分
        merge(a, lo, mid, hi);
    }

}
```

1. 对数组 a[lo..hi] 进行排序，先将它分为 a[lo..mid] 和 a[mid+1..hi] 两部分，通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果；

2. `sort()`方法的作用在于安排多次`merge()`方法调用的正确顺序。



归并排序子数组依赖树：

这棵树有$n$层，对于从$0$到$n-1$的任意$k$，自顶向下的第$k$层有$2^k$个子数组，每个数组的长度为$2^{n-k}$，归并最多需要$2^{n-k}$次比较（即数组长度N）。

因此每层的比较次数为 $2^k×2^{n-k}=2^n$ ，$n$层总共为$n2^n= NlgN$。



对于长度为 N 的任意数组，自顶向下的归并排序：

1. 需要$½NlgN$至$NlgN$次比较；
2. 最多需要访问数组$6NlgN$次

每次归并最多需要访问数组6N次（2N次用来复制，2N次用来将排好序的元素移动回去， 另外最多比较2N次）。



改进：

1. 对小规模子数组使用插入排序；
2. 归并前进行判断：如果a[mid]<=a[mid+1]，则认为数组已经有序；
3. 不复制元素：输入数组 $ \overset{排序}{\rightarrow}$辅助数组，辅助数组 $\overset{排序}{\rightarrow}$ 输入数组



###### 3. 自底向上

首先进行两两归并（将每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并成一个有4个元素的数组），再是八八的归并，一直持续下去。

- 子数组：sz = 1，sz = sz+sz，sz < N，即1, 2, 4, 8, 16, ...

- 子数组索引: lo = 0, lo = lo + sz + sz, 即0, 2sz-1, ...，merge时的索引为(lo, lo+sz-1, lo+sz+sz-1)

```java
public class MergeBU {

    private static Comparable[] aux; // 归并所需的辅助数组

    public static void sort(Comparable[] a) {
        // 进行lgN次两两归并
        int N = a.length;
        aux = new Comparable[a.length];
        for (int sz = 1; sz < N; sz = sz + sz) // sz子数组大小
            for (int lo = 0; lo < N - sz; lo += sz + sz) // lo子数组索引
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
    }

}
```

对于长度为$N$的任意数组，自底向上的归并排序需要$1/2NlgN$至$NlgN$次比较，最多访问数组$6NlgN$次。

处理一个数组的遍数正好是$lgN$（即$2^n ≤N≤2^{n+1}$中的n）。每一遍会访问数组$6N$次，比较次数在$N/2$和$N$之间。

当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。



自顶向下 vs 自底向上：

- 自底向上的归并排序比较适合用 *链表* 组织的数据。只需要重新组织链表链接就能将链表 *原地* 排序。

- 用自顶向下或是自底向上的方式实现任何 *分治* 类的算法都很自然。

- 自顶向下 -> 化整为零（递归解决）

- 自底向上 -> 循序渐进



###### 4. 排序算法复杂度

没有任何基于比较的算法能够保证使用少于 $lg(N!)\sim NlgN$次比较将长度为$N$的数组排序。

任意基于比较的排序算法都对应着一棵高 $h$ 的比较树，其中$N! ≤叶子结点的数量≤ 2^h$。（叶子结点表示一种排列顺序，从根结点到叶子结点每一条路径都对应着算法在建立叶子结点所示的顺序时进行的所有比较。$N$个不同的主键会有$N!$种不同的排列，高度为 $h$ 的二叉树最多只可能有 $2^h$ 个叶子结点。）

$h$ 的值就是最坏情况下的比较次数，因此对不等式的两边取对数即可得到任意算法的比较次数至少是$lgN!$，根据斯特灵公式对阶乘函数的近似可得 $lgN! \sim NlgN$。

归并排序是一种渐进最优的基于比较排序的算法。即归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 $\sim NlgN$。



##### 3. 快速排序

快速排序是一种分治思想的排序算法，它将一个数组分成两个子数组，将两部分独立地排序。与归并排序不同之处在于：归并排序的递归调用发生在处理整个数组之前，而快速排序递归调用发生在处理整个数组之后。



快排算法：
1. 选取切分元素，将数组切分为两个子数组；
2. 再递归调用对两个子数组进行排序；
3. 当两个子数组有序时，整个数组就有序。（这是与归并排序很大的不同）



切分算法：

1. 选择a[lo]为切分元素；
2. 用指针i从左向右开始扫描，找到一个大于等于a[lo]的元素；
3. 用指针j从右向左开始扫描，找到一个小于等于a[lo]的元素；
4. 交换i与j位置的元素；
5. 当i与j相遇时（i==j），交换切分元素a[lo]与a[j]，返回此时切分元素位置j；



快速排序切分示意图：

<div style="text-align: center;"> <img src="https://raw.githubusercontent.com/yonglianghong/my-drive/md/img/Algorithm.Sort.Quick.Partition.jpg" width = "30%" height = "30%"/> </div>


切分函数：

```java
private static int partition(Comparable[] a, int lo, int hi) {
    int i = lo + 1, j = hi;
    Comparable v = a[lo];

    while (true) {
        while (less(a[i++], v)) // 从左向右扫描，直到找到较大的
            if (i > hi) break; // 防止越界，如果a[lo]最大
        while (less(v, a[j++])) ; // 从右向左扫描，直到找到较小的
        exch(a, i, j); // 交换
        if (i >= j) // 如果lo = hi，则此时i > j；a[lo]为最小的元素，也会出现i > j
            break;
    }
    exch(a, lo, j);
    return j;

}
```



整体代码：
```java
public class Quick {

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1); // 将左半部分a[lo...j-1]排序
        sort(a, j + 1, hi); // 将右半部分a[j+1...hi]排序
    }

}
```

注意：
1. 原地切分：不利用辅助数组
2. 别越界：如果切分元素是最小或最大，此时指针i或j将会移动到两端
3. 保持随机：排序前先`shuffle()`或随机选择切分元素
4. 终止循环
5. 终止递归



性能：
- 快速排序的最好情况是每次都正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的$C_{N} = 2C_{N/2} + N$公式。$2C_{N/2}$表示将两个子数组排序的成本，$N$表示用切分元素和所有数组元素进行比较的成本。这个递归公式的解 $C N \sim N lgN$。
- 将长度为 $N$ 的无重复数组排序，快速排序平均需要 $\sim 2NlnN$ 次比较（以及 1/6 的交换）。注 意 到 $2NlnN ≈ 1.39NlgN$，也就是说平均比较次数只比最好情况多39%。
- 快速排序最多需要约 $N^2/2$ 次比较，但随机打乱数组能够预防这种情况。(切分元素始终最小或最大会出现)



改进：
1. 小数组用插入排序：`if (lo + M >= hi) { Insertion.sort(a, lo, hi); return; }`
2. 三取样切分：取样大小设为3，并以大小居中的元素进行切分，还可以将取样元素放在末尾作为“哨兵”来去掉`partition()`中的数组边界测试。（如果选择a[lo]作为切分元素，则a[lo]本身则相当于哨兵。）
3. 三向切分：将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。



Dijkstra解法（荷兰国旗）：
1. 从左到右遍历数组，三个指针，lt、i、gt，lt使得a[lo...lt-1]中的元素都小于v，i使得a[lt...i-1]中的元素都等于v，a[i...gt]中的元素未知，gt使得a[gt+1...hi]中的元素都大于v
2. 一开始v=a[lo],lt=lo,i=lo+1,gt=hi
	- a[i]<v，将a[i]与a[lt]交换，将lt和i加1；
	- a[i]>v，将a[i]与a[gt]交换，将gt减一；
	- a[i]=v，将i加1。
3. 这些操作都会保证数组元素不变且缩小gt-i的值（这样循环才会结束）。

```java
public class Quick3Way {

    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];

        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) exch(a, i++, lt++); // why i++? 因为此时a[i]=v，所以直接将i+1（如果这里不对i+1，再一次循环也会对i+1）
            else if (cmp > 0) exch(a, i, gt--);
            else i++;
        } // 现在 a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]成立
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```

对于只有若干不同主键的随机数组，归并排序的时间复杂度是线性对数的，而三向切分快速排序则是线性的。

对主键概率分布进行分析：

给定包含 $k$ 个不同值的 $N$ 个主键，对于从 1 到 $k$ 的每个 $i$ ，定义 $f_{i}$ 为第 i 个主键值出现的次数， 则概率 $p_{i}$ 为 $f_{i}/N$。所有主键的`香农信息量`：$H=-(p1lgp1+p2lgp2+...+pklgpk)$

- 基于比较的排序算法至少需要 $NH-N$ 次比较（ $H$ 即香农信息量）;
- 对于大小为 $N$ 的数组，三向切分的快速排序需要 $\sim(2ln2)NH$ 次比较;
- 当所有的主键值均不重复时有 $H=lgN$ （所有主键的概率均为 $1/N$ ）

三向切分的最坏情况正是所有主键均不相同，当存在重复主键时，它的性能就会比归并排序好得多。对于任意分布的输入，最优的基于比较的算法平均所需的比较次数和三向切分的快速排序平均所需的比较次数相差范围只在常数因子范围内。

对于包含大量重复元素的数组，它将排序时间从线性对数降低到了线性级别（这和元素的排序顺序没关系，因为排序之前会将其打乱以避免最坏情况）。元素的概率分布决定了信息量的大小，没有基于比较的排序算法能够用少于信息量决定的比较次数完成排序。



##### 4. 优先队列

抽象数据类型：
`public class MaxPQ<Key extends Comparable<Key>>`

- `MaxPQ()`  创建一个优先队列
- `MaxPQ(int max)`	创建一个初始容量为 max 的优先队列
- `MaxPQ(Key[] a)`	用a[]中的元素创建一个优先队列
- `void insert(Key v)`	向优先队列中插入一个元素
- `Key max()`	返回最大元素
- `Key delMax()`	删除并返回最大元素
- `boolean isEmpty()`	返回队列是否为空
- `int size()`	返回优先队列中的元素个数

最重要的操作：删除最大元素和插入元素

实现了Comparable接口的数据的类型作为参数Key，可以不必再区别元素和元素的键

栈：颠倒顺序



优先队列的初级实现：

- 无序数组
- 有序数组
- 无序链表
- 有序链表

使用无序序列是“惰性”方法，仅在必要的时候才会采取行动（找出最大元素）；

使用有序序列是“积极方法”，会尽可能地未雨绸缪（在插入元素时就保持列表有序），使后续操作更高效。

栈和队列，能够实现在 *常数* 时间内完成所有操作；

优先队列，初级实现中，*插入元素* 和 *删除最大元素* 这两个操作在最坏情况下需要 *线性* 时间来完成；

| 数据结构 | 插入元素 | 删除最大元素 |
| -------- | -------- | ------------ |
| 有序数组 | N        | 1            |
| 无序数组 | 1        | N            |
| 堆       | logN     | logN         |
| 理想情况 | 1        | 1            |



二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）

在一个堆中，位置 $k$ 的结点的父结点的位置为 $k/2$，而它的两个子结点的位置则分别为 $2k$ 和 $2k+1$。这样在不使用指针的情况下，可以通过计算数组的索引在树中上下移动：从 $a[k]$ 向上一层就令 $k$ 等于 $k/2$，向下一层则令 $k$ 等于 $2k$ 或 $2k+1$。

一棵大小为 $N$ 的完全二叉树的高度为 $lgN$。



堆的实现：

1. 用长度为 N+1 的私有数组pq[]来表示一个大小为N的堆（不使用pq[0]）。
2. `less(i, j)`
3. `exch(i, j)  // 不再将数组作为参数传递`



堆的有序化（reheapifying）：
- 上浮：某个结点的优先级上升（或是在堆底加入一个新的元素）时，需要 *由下至上* 恢复堆的顺序；
- 下沉：某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，需要 *由上至下* 恢复堆的顺序。

注：将最大元素（根结点）删除后，为什么是将末尾的结点移到根结点的位置？

将根结点删除后，可以从根结点的子结点选取一个较大的放在根结点位置，此时子结点空缺一个，再从子结点的子结点选取一个较大的，以此类推，直到整体恢复。

这与将末尾结点放到根结点位置，然后根结点的较大子结点与之交换，再选取子结点的子结点与之交换，...，直到整体恢复，实现的效果一致。

代码：
```java
private void swim(int k) {
    while (k > 1 && less(k / 2, k)) {
        exch(k / 2, k);
        k /= 2;
    }
}

private void sink(int k) {
    while (2 * k <= N) {
        int j = 2 * k;
        if (j < N && less(j, j + 1)) // j == N ?
            j++;
        if (less(j, k)) break;
        exch(j, k);
        k = j;
    }
}
```
`sink()`时，当j==N，因为满二叉树结点数：$2^0+2^1+...+2^n=2^n-1$，所以出现这种情况，此时一定是完全二叉树，即N为最后一个结点，且是左结点。

优先队列由一个基于堆的完全二叉树表示，存储于数组pq[1...N]中，pq[0]没有使用。

在`insert()`中，将N加1并把新元素添加在数组最后，然后用swim()恢复堆的秩序。

在`delMax()`中，从pq[1]中得到需要返回的元素，然后将pq[N]移动到pq[1]，将N减一并用sink()恢复堆的秩序。

同时还将不再使用的pq[N+1]设为null，以便系统回收它所占用的空间。



性能：对于一个含有N个元素的基于堆的优先队列

- *插入元素* 操作只需最多lgN次比较
- *删除最大元素* 的操作最多需要2lgN次比较



多叉堆：
可以用完全三叉树构造堆，对于数组中1至N的N个元素，位置k的结点大于等于位于$3k-1$、$3k$和$3k+1$的结点，小于等于位于 $(k+1)/3$ 的结点。

对于给定的 $d$ ，将其修改为任意的d叉树也并不困难。我们需要在树高（$log_{d}N$）和在每个结点的 $d$ 个子结点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度。



索引优先队列

`public class IndexMinPQ <Item extends Comparable<Item>>`

- `IndexMinPQ(int maxN)`	创建一个最大容量为 maxN 的优先队列， 索引的取值范围 为 0 至 maxN-1
- `void	insert(int k, Item item)`	插入一个元素，将它和索引k相关联
- `void	change(int k, Item item)`	将索引为k的元素设为item
- `boolean	contains(int k)` 是否存在索引为k的元素
- `void delete(int k)`	删除索引k及其相关联的元素
- `Item min()`	返回最小元素
- `int minIndex()`	返回最小元素的索引
- `int	delMin()`	删除最小元素并返回它的索引
- `boolean	isEmpty()` 优先队列是否为空
- `int size()`	优先队列中元素的数量	

？改变后重新保持堆化？看成一个能够快速访问其中最小元素的数组。将名为pq的IndexMinPQ()看做数组pq[0...N-1]中的一部分元素的代表？

性能：

大小为N的索引优先队列，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和lgN成正比



多向归并：将多个有序输入流归并成一个有序的输出流。

```java
public class Multiway {
  public static void merge(In[] streams) {
    int N = streams.length;
    IndexMinPQ<String> pq = new IndexMinPQ<String>(N);
    // 初始化
    for (int i = 0; i < N; i++)
      if (!streams[i].isEmpty()) // 如果输入流不为空
        pq.insert(i, streams[i].readString());
    
    while (!pq.isEmpty()) {
      StdOut.println(pq.min());
      int i = pq.delMin(); // 删除一个最小元素，返回索引，由索引知道当前最小元素对应的输入流
      if (!streams[i].isEmpty())
        pq.insert(i, streams[i].readString()); // 插入最小元素对应的输入流的下一个元素
    }
  }

  public static void main(String[] args) { 
    int N = args.length; 
    In[] streams = new In[N]; 
    for (int i = 0; i < N; i++) 
      streams[i] = new In(args[i]);
    merge(streams); 
  }
  
}
```



堆排序：

将所有元素插入一个查找最小元素的优先队列，再重复调用删除最小元素操作，相当于进行了一次排序。（用无序数组实现的优先队列这么做相当于进行一次选择排序。）



堆排序分为两个阶段：

- 堆的构造：
	- 从左向右遍历数组，用`swim()`保持扫描指针左侧的所有元素已经是一颗堆有序的完全树即可（连续向优先队列中插入元素）
	- 在N/2处，从右向左遍历数组，调用`sink()`方法（如果一个结点的两个子结点是堆，在该结点上调用sink()可以构造一个堆）
	- 用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换
- 下沉排序：将根结点交换到最后，模拟删除堆顶元素



性能：
将 $N$ 个元素排序，堆排序只需少于 $(2NlgN+2N)$ 次比较（以及一半次数的交换）。（$2N$项来自于堆的构造。 $2NlgN$ 项来自于每次下沉操作最大可能需要 $2lgN$ 次比较）

先下沉再上浮？
> Most items reinserted into the heap during sortdown go all the way to the bottom. Floyd observed in 1964 that we can thus save time by avoiding the check for whether the item has reached its position, simply promoting the larger of the two children until the bottom is reached, then moving back up the heap to the proper position. This idea cuts the number of compares by a factor of 2 asymptotically—close to the number used by mergesort (for a randomly-ordered array). The method requires extra bookkeeping, and it is useful in practice only when the cost of compares is relatively high (for example, when we are sorting items with strings or other types of long keys).



优点与缺点：

- 唯一能够同时最优地利用空间和时间的方法——在最坏的情况下它也能保证使 用～ 2NlgN次比较和恒定的额外空间。
当空间十分紧张的时候（例如在嵌入式系统或低成本的移动设备中）它很流行，因为它只用几行就能实现（甚至机器码也是）较好的性能。
- 无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。