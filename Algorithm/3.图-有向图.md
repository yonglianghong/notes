##### 1. 定义

Set of vertices connected pairwise by directed edges.（成对的点，有向边，连接）

Digraph applications：

| digraph               | vertex              | directed edge              |
| --------------------- | ------------------- | -------------------------- |
| transportation        | street intersection | one-way street             |
| web                   | web page            | hyperlink                  |
| food web              | species             | predator-prey relationship |
| WordNet               | synset              | hypernym                   |
| scheduling            | task                | precedence constraint      |
| financial             | bank                | transaction                |
| cell phone            | person              | placed call                |
| infectious disease    | person              | infection                  |
| game                  | board position      | legal move                 |
| citation              | journal article     | citation                   |
| object graph          | object              | pointer                    |
| inheritance hierarchy | class               | inherits from              |
| control flow          | code block          | jump                       |

Digraph problems：

- Shortest path. What is the shortest directed path from *s* to *t* ?

- Topological sort. Can you draw a digraph so that all edges point upwards?

- Strong connectivity. Is there a directed path between all pairs of vertices?

- Transitive closure. For which vertices *v* and *w* is there a path from *v* to *w* ?

- PageRank. What is the importance of a web page?



##### 2. 实现

1. API:

   |       public class | Digraph               |                                         |
   | -----------------: | --------------------- | --------------------------------------- |
   |                    | Digraph(int V)        | create an empty digraph with V vertices |
   |                    | Digraph(In n)         | create a digraph from input stream      |
   |               void | addEdge(int v, int w) | add a directed edge v→w                 |
   | Iterable\<Integer> | adj(int v)            | vertices pointing from v                |
   |                int | V()                   | number of vertices                      |
   |                int | E()                   | number of edges                         |
   |            Digraph | reverse()             | reverse of this digraph                 |
   |             String | toString()            | string representation                   |

2. Digraph representations: Adjacency-lists

3. 代码：

   ```java
   public class Digraph {
   
       private final int V; // 顶点数
       private int E; // 边数
       private final Bag<Integer>[] adj;
   
       public Digraph(int V) {
           this.V = V;
           adj = (Bag<Integer>[]) new Bag[V];
           for (int i = 0; i < V; i++) {
               adj[i] = new Bag<Integer>();
           }
       }
   
       public void addEdge(int v, int w) {
           adj[v].add(w);
           E++;
       }
   
       public Iterable<Integer> adj(int v) {
           return adj[v];
       }
   
       public int V() { // 顶点数
           return V;
       }
   
       public int E() { // 边数
           return E;
       }
     
     	public Digraph reverse() {
           Digraph R = new Digraph(V); // 构造新图
           for (int v = 0; v < V; v++) {
               for (int w : adj(v))
                   R.addEdge(w, v); // 逆序
           }
           return R;
       }
   
   }
   ```

4. 性能：

   |  representation  |       space       | insert edge from v to w |     edge from v and w?     | iterate over vertices pointing from v? |
   | :--------------: | :---------------: | :---------------------: | :------------------------: | :------------------------------------: |
   |  list of edges   |  $\scriptsize E$  |     $\scriptsize 1$     |      $\scriptsize E$       |            $\scriptsize E$             |
   | adjacency matrix | $\scriptsize V^2$ |     $\scriptsize 1$     |      $\scriptsize 1$       |            $\scriptsize V$             |
   | adjacency lists  | $\scriptsize E+V$ |     $\scriptsize 1$     | $\scriptsize outdegree(v)$ |       $\scriptsize outdegree(v)$       |



##### 3. 搜索

1. Depth-ﬁrst search

   - Every undirected graph is a digraph (with edges in both directions).
   - DFS is a digraph algorithm.

   - DFS (to visit a vertex v)
     - Mark v as visited.
     - Recursively visit all unmarked vertices w pointing from v.

2. Breadth-ﬁrst search

   - Every undirected graph is a digraph (with edges in both directions).

   - BFS is a digraph algorithm.
   - BFS (from source vertex s)
   	- Put s onto a FIFO queue, and mark s as visited.
   	- Repeat until the queue is empty:
   	  - remove the least recently added vertex v
   	  - for each unmarked vertex pointing from v:
   	  - add to queue and mark as visited.

3. DFS应用：
   1. Reachability application: program control-ﬂow analysis
   2. Reachability application: mark-sweep garbage collector
   3. Depth-ﬁrst search in digraphs summary
      - DFS enables direct solution of simple digraph problems.
        - Reachability.
        - Path finding.
        - Topological sort.
        - Directed cycle detection.
      - Basis for solving difficult digraph problems.
        - 2-satisfiability.
        - Directed Euler path.
        - Strongly-connected components.
   4. BFS应用:
      1. multiple-source shortest paths.
      2. web crawler



##### 4. Topological sort（拓扑排序）

1. In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. 

2. postorder: The order in which we're done with the vertices, that's called postorder.

3. 参考：https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86
4. Topological sort: Redraw DAG(<u>***Directed acyclic graph***</u>) so all edges point upwards.

5. 实现：

   ```java
   public class DepthFirstOrder {
   
       private boolean[] marked;
       private Stack<Integer> reversePost;
   
       public DepthFirstOrder(Digraph G) {
           reversePost = new Stack<>();
           marked = new boolean[G.V()];
           for (int v = 0; v < G.V(); v++) {
               if (!marked[v])
                   dfs(G, v);
           }
       }
   
       private void dfs(Digraph G, int v) {
           marked[v] = true;
           for (int w : G.adj(v)) {
               if (!marked[w])
                   dfs(G, w);
           }
           reversePost.push(v);
       }
   
       public Iterable<Integer> reversePost() {
           return reversePost;
       }
   
   }
   ```

6. 证明：

   <div style="text-align: left;"> <img src="https://raw.githubusercontent.com/yonglianghong/my-drive/md/img/Topological.Sort.In.DAG.jpg"  width = "60%" height = "60%"/>
   </div>

7. directed cycle（有向环）：

   ```java
   public class DirectedCycle {
   
       private boolean[] marked;
       private int[] edgeTo;
       private Stack<Integer> cycle; // 有向环中的所有顶点
       private boolean[] onStack; // 递归调用的栈上的所有顶点
       
       private void dfs(Digraph G, int v) {
           onStack[v] = true;
           marked[v] = true;
           for (int w : G.adj(v)) {
               if (hasCycle())
                   return;
               else if (!marked[w]) {
                   edgeTo[w] = v;
                   dfs(G, w);
               } else if (onStack[w]) {
                   cycle = new Stack<>(); // 有才初始化
                   for (int x = v; x != w; x = edgeTo[x]) // 利用w作为终止条件
                       cycle.push(x);
                   cycle.push(w);
                   cycle.push(v);
               }
           }
           onStack[v] = false; // 调用完成置为false
       }
   
       public boolean hasCycle() {
           return cycle != null;
       }
   
       public Iterable<Integer> cycle() {
           return cycle;
       }
   
   }
   ```



##### 5. Strongly-connected components 强连通分支

1. Def. Vertices v and w are strongly connected if there is both a directed path from v to w and a directed path from w to v.（若存在v -> w，则存在w -> v
2. Application: 

- - ecological food webs. Vertex = species; edge = from producer to consumer.
  - Software module dependency graph. Vertex = software module. Edge: from module to dependency.

2. Kosaraju-Sharir algorithm:
   1. intuition（直觉）：
      - Reverse graph. Strong components in G are same as in $\scriptsize G^R$ .
      - Kernel DAG. Contract each strong component into a single vertex.（将strong component当作单个顶点）
   2. algorithm：
      - Phase 1. run DFS on  $\scriptsize G^R$ to compute reverse postorder. 
      - Phase 2. run DFS on G, considering vertices in order given by first DFS.

3. 代码：

   ```java
   public class KosarajuSharirSCC {
   
       private boolean[] marked;
       private int[] id;
       private int count;
   
       public KosarajuSharirSCC(Digraph G) {
           marked = new boolean[G.V()];
           id = new int[G.V()];
           DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());
           for (int v : dfs.reversePost()) {
               if (!marked[v]) {
                   dfs(G, v);
                   count++;
               }
           }
       }
   
       private void dfs(Digraph G, int v) {
           marked[v] = true;
           for (int w : G.adj(v)) {
               if (!marked[w])
                   dfs(G, w);
           }
       }
   
       public boolean stronglyConnected(int v, int w) {
           return id[v] == id[w];
       }
   
   }
   ```

4. 性能：

   Kosaraju-Sharir algorithm computes the strong components of a digraph in time proportional to E + V.

