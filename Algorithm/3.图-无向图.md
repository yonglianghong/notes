##### 1. 定义与实现

1. 图的定义：由顶点（vertex）与边（edge）构成。

2. 图的表示：顶点的名字可以用symbol table将name` ->` index，这样方便且不损失效率。

3. Graph API：

   |       public class | Graph                 |                           |
   | -----------------: | --------------------- | ------------------------- |
   |                    | Graph(int V)          | 创建一个包含v个顶点的空图 |
   |                    | Graph(In in)          | 用输入流创建图            |
   |               void | addEdge(int v, int w) | 添加一条边v-w             |
   | Iterable\<Integer> | adj(int v)            | 与v相邻的点集合           |
   |                int | V()                   |                           |
   |                int | E()                   |                           |

4. 实现（implement）：

   - set-of-edges graph representation （maintain a list of the edges）
   - adjacency-matrix graph representation 邻接矩阵
   - adjacency-list graph representation 邻接表（vertex-indexed array of lists. 数组+链表，链表保存一个顶点的相邻顶点）

5. 代码：

   ```java
   public class Graph {
       
       private final int V; // 顶点数
       private int E; // 边数
       private Bag<Integer>[] adj;
   
       public Graph(int V) {
           this.V = V;
           adj = (Bag<Integer>[]) new Bag[V];
           for (int i = 0; i < V; i++)
               adj[i] = new Bag<>();
       }
   
       public void addEdge(int v, int w) { // 添加边
           adj[v].add(w);
           adj[w].add(v);
           E++;
       }
   
       public Iterable<Integer> adj(int v) {
           return adj[v];
       }
   
       public int V() { // 顶点数
           return V;
       }
   
       public int E() { // 边数
           return E;
       }
     
   }
   ```

6. 公共计算：

   ```java
       // 计算v的度数
       public static int degree(Graph g, int v) {
           int degree = 0;
           for (int w : g.adj(v))
               degree++;
           return degree;
       }
   
       // 计算最大度
       public static int maxDegree(Graph g) {
           int max = 0;
           for (int v = 0; v < g.V(); v++) {
               if (max < degree(g, v))
                   max = degree(g, v);
           }
           return max;
       }
   
       // 计算平均度
       public static int averageDegree(Graph g) {
           return g.E() * 2 / g.V();
       }
   
       // 计算自环的个数
       public static int numberOfSelfLoops(Graph g) {
           int count = 0;
           for (int v = 0; v < g.V(); v++)
               for (int w : g.adj(v))
                   if (v == w)
                       count++;
           return count / 2; // 每条边计算了两遍？
       }
   ```

7. 性能：

   |  representation  |       space       |    add edge     |  edge betwee v and w?   | iterate over vertices adjacent to v? |
   | :--------------: | :---------------: | :-------------: | :---------------------: | :----------------------------------: |
   |  list of edges   |  $\scriptsize E$  | $\scriptsize 1$ |     $\scriptsize E$     |           $\scriptsize E$            |
   | adjacency matrix | $\scriptsize V^2$ | $\scriptsize 1$ |     $\scriptsize 1$     |           $\scriptsize V$            |
   | adjacency lists  | $\scriptsize E+V$ | $\scriptsize 1$ | $\scriptsize degree(v)$ |       $\scriptsize degree(v)$        |



##### 2. depth-first search 深度优先搜索

1. 原理：迷宫探索（maze exploration）

   - Unroll a ball of string behind you. 想象用一个球来记录轨迹

   - Mark each visited intersection and each visited passage. 标记走过的通道和路口

   - Retrace steps when no unvisited options.  如果无法继续，则原路返回到上一个岔路口

2. 实现：

   设计模式（Design pattern）：将图本身与图处理分开。（Decouple graph data type from graph processing.）

   |       public class | Paths               |                                          |
   | -----------------: | ------------------- | ---------------------------------------- |
   |                    | PathGraph G, int s) | *find paths in G from source s*          |
   |            boolean | hasPathTo(int v)    | *is there a path from s to v?*           |
   | Iterable\<Integer> | pathTo(int v)       | *path from s to v; null if no such path* |

3. 算法：

   Goal: Find all vertices connected to s (and a corresponding path).

   To visit a vertex v:

   1. Mark vertex v as visited.（将v标记为访问过）
   2. Recursively visit all unmarked vertices adjacent to v.（递归访问v的相邻顶点中未被访问的）

   3. Return (retrace steps) when no unvisited options.

   当逐层递归调用时，一条path执行完毕（无路可走），会自动返回到上层函数栈（实现沿原路返回的效果）。

4. 数据结构（Data Structures）：

   1. `boolean[] marked` 标记访问过的顶点

   2. `int[] edgeTo` 记录访问到当前index的顶点的path（keep tree of paths. 类似于树中从父结点到子结点）

      (`edgeTo[w] == v`) means that edge v-w taken to visit w for first time

5. 代码：

   ```java
   public class DepthFirstPaths {
   
       private boolean[] marked; // 是否被visited
       private int[] edgeTo; // edgeTo[w]=v，表示v->w
       private int s;
   
       public DepthFirstPaths(Graph g, int s) {
           this.s = s;
           dfs(g, s);
       }
   
       private void dfs(Graph g, int v) {
           marked[v] = true;
           for (int w : g.adj(v)) {
               if (!marked[w]) {
                   dfs(g, w);
                   edgeTo[w] = v; // 从v到达w
               }
           }
       }
   
       public boolean hasPathTo(int v) {
           return marked[v];
       }
   
       public Iterable<Integer> pathTo(int v) {
           if (!marked[v])
               return null;
           Stack<Integer> path = new Stack<>();
           for (int x = v; x != s; x = edgeTo[x]) // edgeTo[w]=v，表示v->w，因此x=edgeTo[x]表示逐次向上递归，直到递归到s
               path.push(x);
           path.push(s); // 栈后进先出，最后放入s
           return path;
       }
   
   }
   ```

6. 性能：

   1. DFS marks all vertices connected to s in time proportional to the sum of their degrees.

   2. After DFS, can find vertices connected to s in constant time and can find a path to s (if one exists) in time proportional to its length.

   3. edgeTo[] is parent-link representation of a tree rooted at s.



##### 3. breadth-first search 广度优先搜索

1. 算法：

   Put s onto a FIFO queue, and mark s as visited. （准备一个队列，记录访问过的v）

   Repeat until queue is empty. 重复以下过程，直到队列为空。

   1. remove the least recently added vertex v. 移除最早添加的顶点v

   2. add each of v's unvisited neighbors to the queue, and mark them as visited. 将v的邻接点（未被访问）添加进queue并标记访问。

2. 代码：

   ```java
   public class BreadthFirstPaths {
   
       private boolean[] marked;
       private int[] edgeTo;
   
       private void bfs(Graph g, int s) {
           Queue<Integer> queue = new Queue<>();
           queue.enqueue(s);
           marked[s] = true;
           while (!queue.isEmpty()) {
               int v = queue.dequeue();
               for (int w : g.adj(v)) {
                   if (!marked[w]) {
                       queue.enqueue(w);
                       marked[w] = true;
                       edgeTo[w] = v;
                   }
               }
           }
       }
   }
   ```

3. `stack` vs `queue`:

   Depth-first search. Put unvisited vertices on a stack.（函数栈，区别于`pathTo(int v)`方法中用到的栈）

   Breadth-first search. Put unvisited vertices on a queue.

4. Shortest path:

   Find path from s to t that uses fewest number of edges. BFS examines vertices in increasing distance from s.

   BFS中的路径，是最短路径。

5. 性能：

   1. BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V.



##### 4. connected components（连通分支）

1. 目标与定义：

   Preprocess graph to answer queries of the form is v connected to w in constant time.（在查询v-w是否连通时（connectivity queries），可以常数级时间返回。）

   A connected component is a maximal set of connected vertices.

   The relation "is connected to" is an equivalence relation:

   - Reflexive: v is connected to v.

   - Symmetric: if v is connected to w, then w is connected to v.

   - Transitive: if v connected to w and w connected to x, then v connected to x.

2. API:

   | pulic class | CC                      |                                  |
   | ----------: | ----------------------- | -------------------------------- |
   |             | CC(Graph G)             | *ﬁnd connected components in G*  |
   |     boolean | connected(int v, int w) | *are v and w connected?*         |
   |         int | count()                 | *number of connected components* |
   |         int | id(int v)               | *component identiﬁer for v*      |

3. 算法：

   Partition vertices into connected components.

   Initialize all vertices v as unmarked.

   For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.

   To visit a vertex v :

   - Mark vertex v as visited.

   - Recursively visit all unmarked vertices adjacent to v.

4. 代码：

   ```java
   public class CC {
   
       private boolean[] marked;
       private int[] id;
       private int count;
   
       public CC(Graph g) {
           marked = new boolean[g.V()];
           id = new int[g.V()];
           for (int v = 0; v < g.V(); v++) {
               if (!marked[v]) {
                   dfs(g, v);
                   count++;
               }
           }
       }
   
       public int count() {
           return count;
       }
   
       public int id(int v) {
           return id[v];
       }
   
       private void dfs(Graph g, int v) {
           marked[v] = true;
           id[v] = count;
           for (int w : g.adj(v)) {
               if (!marked[w])
                   dfs(g, w);
           }
       }
   
   }
   ```

   

