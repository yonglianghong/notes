> 将链表插入的灵活性与有序数组查找的高效性相结合，就可以得到二叉查找树。
>
> 每个结点含有两个链接（vs 链表：每个结点含有一个链接）



##### 1. 定义

数据结构：由 *结点* 构成，结点包含的 *链接* 可以为空（null）或者指向其他结点

二叉树：

1. 每个结点只能有一个父结点（根结点例外）
2. 每个结点只有 *左右* 两个链接，分别指向左子结点和右子结点
3. 每个链接都指向一棵（独立的）子二叉树

二叉查找树（BST）就是一棵二叉树，每个结点还包含一个Comparable的键和一个值，且每个结点的键都大于其左子树中的任意结点的键，小于其右子树的任意结点的键。


一棵二叉查找树代表了一组键（及其相应的值）的集合， 而同一个集合可以用多棵不同的二叉查找树表示。（即根结点不一样，只要保证投影的序列一样即可）



##### 2. 基本实现

1. 查找：
   1. 如果树为空，则查找未命中
   2. 比较查找的键与根结点的键
      1. 小于，则递归查找左子树
      2. 大于，则递归查找右子树
      3. 等于，查找命中
   3. 随着不断向下查找，当前结点所表示的子树的大小也在减小（直至命中或为空）



2. 插入：
    1. 与插入类似，都是在链接终止处构建新结点（命中或者未命中都如此）（从根结点开始，每个结点都含有两个链接，树会逐渐长大而不是萎缩）
    2. 从下往上重置链接
    3. 从下往上更新结点计数器



3. 递归：
   1. 递归调用前：`沿着树向下走`

   2. 递归调用后：`沿着树向上爬`

     - `get()`：对应值一系列的的返回指令(return)`

     - `put()`：重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值



4. 性能：
    1. 最好$\sim lgN$，最坏$\sim N$
    2. 二叉查找树 vs 快速排序：树的根结点就是快速排序中的第一个切分元素，子树以此类推
    3. 含有N个键的二叉查找树中，插入操作、查找命中/查找未命中平均所需的比较次数为$\sim 2lnN$（约$1.39lgN$）
     - 一次命中查找所需的比较次数为查找路径的深度加1（加1是?）
     - 插入或查找未命中需要一次额外的比较？



##### 3. 有序性操作

1. 最大键和最小键：参考投影

   - 最小：

     1. 如果根结点的左链接为空，则最小的为根结点

     2. 如果根结点的左链接非空，则最小键就是左子树的最小键

   - 最大：
     1. 如果根结点的右链接为空，则最大的为根结点
     2. 如果根结点右链接非空，则最大键就是右子树的最大键



2. 向上取整和向下取整：参考投影

   - 向下：
     1. 如果给定的键key小于根结点的键，则小于等于key的最大键floor(key)在根结点的左子树中
     2. 如果给定的键key大于根结点的键，除非根结点的右子树中有小于给定key的结点，否则根结点就是小于等于key的最大键
     3. 如果给定的键key等于根结点的键，则返回根结点

   - 向上：
     1. 如果给定键key大于根结点的键，则大于等于key的最小键在根结点的右子树中
     2. 如果给定键key小于根结点的键，除非根结点的左子树有大于给定key的键（即在右子树存在ceiling(key)），否则返回根结点
     3. 如果给定键key等于根结点的键，则返回根结点



3. 选择
   1. 找到排名为k的键（即树中正好有k个小于它的键）
   2. 如果根结点左子树的结点数t>k，则在左子树中递归查找
   3. 如果根结点左子树的结点数t=k，则返回根结点
   4. 如果根结点左子树的结点数t<k，则在右子树中递归查找排名为(k-t-1)的结点



4. 排名
   1. 给定键与根结点的键相等，则返回左子树中的结点总数t
   2. 给定键小于根结点的键，则在根结点的左子树中递归计算排名
   3. 给定键大于根结点的键，则返回左子树的结点数t+1+在右子树中的排名



5. 删除最大和最小键
   1. <u>*同`put()`方法一样，递归方法接受一个指向结点的链接，并返回一个指向结点的链接（这样就能够方便地改变树的结构，将返回的链接赋给作为参数的链接）*</u>
   2. 向左递归根结点，直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）
   3. 更新结点计数器



6. 删除



7. 范围查找



8. 性能
   - 在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。
   - 二叉查找树的平均高度为树中结点数的对数级别，对于足够大的N，这个值趋近于2.99lgN。随机构造的树中的所有路径长度都小于3lgN
   - 非递归效率更高？



##### 4. 递归

递归终止条件

结点本身是否为空

结点左右子结点是否为空